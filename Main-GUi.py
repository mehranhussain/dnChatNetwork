# dnClient.py
# Example Usage: python chatClient.py localhost 42015

# importing required modules
import socket
import select
import sys
from random import randint
import threading
try:
    import Tkinter, ttk
except:
    import tkinter as Tkinter
    import tkinter.ttk as ttk

if len(sys.argv) < 3:
    print 'Usage : python chatClient.py hostname port'
    sys.exit()

host = sys.argv[1]
port = int(sys.argv[2])

# State of the connection
CONNECTED = False
AUTHENTICATED = False

# Protocol implementation

commands = ['AUTH', 'SEND', 'ACKN', 'OKAY', 'FAIL', 'INVD', 'ARRV', 'LEFT', 'SRVR']

class SOCKETS:
    def __init__(self):
        # Declaring socket
        s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)

    def load(self, ip_address, port, text,status,server_info):
        self.ip_address = ip_address
        self.port = port
        self.history = text
        self.status = status
        self.server_info = server_info
        return

    def bind(self):
        while True:
            try:
                s.connect((host, port))
                s.settimeout(2)

                # Connect to chatServer
                try:
                    s.connect((host, port))
                except:
                    print 'Unable to connect to chatServer.'
                    sys.exit()

                CONNECTED = True
                print 'Connected to chatServer.'

                threading.Thread(target=self.recv).start()
                break

            except:
                pass

    def recv(self):
        authFlag = True

        # Authentication Stage
        while 1:
            if not authFlag:
                break
            if CONNECTED == True:
                # Random number generated for chatClient Reference, ask for name and password
                chatClientReference = randint(1, 100)

                chatClientName = "dsdsdds"
                chatClientPassword = "dnServer"

                authMessage = commands[0]
                authMessage += " "
                authMessage += str(chatClientReference)
                authMessage += " \r\n"
                authMessage += chatClientName
                authMessage += "\r\n"
                authMessage += chatClientPassword

                s.send(authMessage)

            socket_list = [sys.stdin, s]

            # Get the list sockets which are readable
            read_sockets, write_sockets, error_sockets = select.select(socket_list, [], [])

            for sock in read_sockets:
                # Incoming message from chatServer
                if sock == s:
                    data = sock.recv(4096)
                    authResponse = data.split()
                    print authResponse

                    # If OKAY
                    if data == commands[3] + " " + str(chatClientReference):
                        authFlag = False
                        AUTHENTICATED = True
                        break

                    # If FAIL
                    elif authResponse[0] == commands[4]:
                        if authResponse[2] == "PASSWORD":
                            self.printData(authResponse[0] + " " + authResponse[1] + " " + authResponse[
                                2] + ": The password is not acceptable for authentication on this server.")
                        elif authResponse[2] == "NAME":
                            self.printData(authResponse[0] + " " + authResponse[1] + " " + authResponse[
                                2] + ": The specified name is already in use by another client.")
                        elif authResponse[2] == "NUMBER":
                            self.printData(authResponse[0] + " " + authResponse[1] + " " + authResponse[
                                2] + ": A number is not valid, either because it has already been used for another entity in case it was newly generated by the client, or there is no relevant entity that the number refers to.")

        # When client is connected and authenticated
        while 1:
            socket_list = [sys.stdin, s]
            # Get the list sockets which are readable
            read_sockets, write_sockets, error_sockets = select.select(socket_list, [], [])

            # Random number generated for chatMesssageReference
            chatMessageReference = randint(1, 10000)

            for sock in read_sockets:

                # Incoming message from chatServer

                if sock == s:
                    data = sock.recv(4096)
                    authResponse = data.split()

                    # If OKAY
                    if data == commands[3] + " " + str(chatMessageReference):
                        self.printData(data)

                    # If SEND
                    elif authResponse[0] == commands[1]:
                        self.printData(data)
                        s.send("ACKN " + authResponse[1] + "\r\n" + authResponse[2])

                    # If ARRV
                    elif authResponse[0] == commands[6]:
                        self.printData("The following user is connected now.\r\nUser Reference: " + authResponse[
                            1] + "\r\nUsername: " + authResponse[2] + "\r\nIpAddress: " + authResponse[3])

                    # If LEFT
                    elif authResponse[0] == commands[7]:
                        self.printData("The following user has left.\r\nUser Reference: " + authResponse[1])

                    # If FAIL
                    elif authResponse[0] == commands[4]:
                        if authResponse[2] == "LENGHT":
                            self.printData(authResponse[0] + " " + authResponse[1] + " " + authResponse[
                                2] + ": The chat message text is too long.")
                        elif authResponse[2] == commands[5]:
                            self.printData(authResponse[0] + " " + authResponse[1] + " " + authResponse[
                                2] + ": A malformed message or a message that is not valid in the current state of the client.")
                            s.close()
                            self.printData("Connection to chatServer closed.")
                    else:
                        self.printData(data)

                else:
                    if AUTHENTICATED == True:
                        chatMessageInput = sys.stdin.readline()
                        chatMessageRcvr = raw_input("Enter * for broadcasting or Reference Number of specific client: ")

                        chatMessage = commands[1]
                        chatMessage += " "
                        chatMessage += str(chatMessageReference)
                        chatMessage += " \r\n"
                        chatMessage += chatMessageRcvr
                        chatMessage += "\r\n"
                        chatMessage += chatMessageInput

                    s.send(chatMessage)

    def printData(self,data):
        data = 'Other : ' + data + '\n'
        start = self.history.index('end') + "-1l"
        self.history.insert("end", data)
        end = self.history.index('end') + "-1l"
        self.history.tag_add("Received", start, end)
        self.history.tag_config("Received", foreground='green')

class ClientMode(Tkinter.Tk):
    def __init__(self, *args, **kwargs):
        Tkinter.Tk.__init__(self, *args, **kwargs)
        self.resizable(0, 0)
        self.create_additional_widgets()

    def socket_connections_start(self):
        if len(host.split('.')) == 4:
            print("Thread Started")
            threading.Thread(target=socket_connections).start()

    def socket_connections(self):
        print("[=] Bindings")
        s.bind()

    def create_additional_widgets(self):
        self.create_panel_for_widget()
        self.create_panel_for_connections_info()
        self.create_panel_for_chat_history()
        self.create_panel_for_sending_text()
        self.create_panel_for_authentication_text()


    def send_text_message(self):
        if CONNECTED == True:
            input_data = self.Sending_data.get('1.0', 'end')
            if len(input_data) != 1:
                s.send(input_data)
                input_data = 'me: ' + input_data
                start = self.history.index('end') + "-1l"
                self.history.insert("end", input_data)
                end = self.history.index('end') + "-1l"
                self.history.tag_add("SENT", start, end)
                self.Sending_data.delete('1.0', 'end')
                self.history.tag_config("SENT", foreground='Blue')

                pass
            else:
                print("Enter Correct information")

        else:
            print("No Connection")

    def create_panel_for_authentication_text(self):
        # Here Creating Authentication Panel
        self.username = Tkinter.Text(self.Authenticaion_panel, font=('arial 12 italic'), width=18, height=1)
        self.username.pack(side='left')
        self.password = Tkinter.Text(self.Authenticaion_panel, font=('arial 12 italic'), width=18, height=1)
        self.password.pack(side='left')
        self.authentication_Trigger = Tkinter.Button(self.Authenticaion_panel, text='Authenticate', width=15, height=1,
                                              command=self.get_data)
        self.authentication_Trigger.pack(side='left')
        return

    def get_data(self):
        username = self.username.get('1.0', 'end')
        password = self.password.get('1.0', 'end')
        self.username.config(state='disable')
        self.password.config(state='disable')
        self.authentication_Trigger(state='disable')



    def create_panel_for_sending_text(self):
        # Here Creating Sending Panel
        self.Sending_data = Tkinter.Text(self.Sending_panel, font=('arial 12 italic'), width=37, height=2)
        self.Sending_data.pack(side='left')
        self.Sending_Trigger = Tkinter.Button(self.Sending_panel, text='Send', width=15, height=2,
                                              command=self.send_text_message)
        self.Sending_Trigger.pack(side='left')
        return

    def create_panel_for_chat_history(self):
        # Here Creating Chat History
        self.history = Tkinter.Text(self.history_frame, font=('arial 12 bold italic'), width=50, height=15)
        self.history.pack()
        return

    def create_panel_for_widget(self):
        self.Authenticaion_panel = Tkinter.LabelFrame(self, text='Authentication')
        self.Authenticaion_panel.pack(side='top')
        # First For Connection Information
        self.Connection_info = Tkinter.LabelFrame(self, text='Server')
        self.Connection_info.pack(side='top', expand='yes', fill='both')
        # Creating Second For Chatting History
        self.history_frame = Tkinter.LabelFrame(self, text='Chat History')
        self.history_frame.pack(side='top')
        # Creating Third For Sending Text Message
        self.Sending_panel = Tkinter.LabelFrame(self, text='Send Message')
        self.Sending_panel.pack(side='top')
        return

    def create_panel_for_connections_info(self):
        self.frame = ttk.Frame(self.Connection_info)
        self.frame.pack(side='top', padx=10, pady=10)
        # Creating Main Information Panel
        ttk.Label(self.frame, text='Host: ', relief="groove", anchor='center', width=25).grid(row=1,
                                                                                                                 column=1,
                                                                                                                 ipadx=10,
                                                                                                                 ipady=5)
        ttk.Label(self.frame, text=host, relief='sunken', anchor='center', width=25).grid(row=1,
                                                                                                             column=2,
                                                                                                             ipadx=10,
                                                                                                             ipady=5)
        ttk.Label(self.frame, text='Port: ', relief="groove", anchor='center', width=25).grid(
            row=2, column=1, ipadx=10, ipady=5)
        ttk.Label(self.frame, text=port, relief="sunken", anchor="center", width=25).grid(row=2, column=2,
                                                                                                       ipadx=10,
                                                                                                       ipady=5)

        return


if __name__ == '__main__':
    ClientMode(className='chatClient').mainloop()

